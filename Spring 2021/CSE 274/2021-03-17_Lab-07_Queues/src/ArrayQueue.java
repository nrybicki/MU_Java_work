import java.util.NoSuchElementException;/** * A class that implements the ADT queue by using a resizable circular array. *  */public final class ArrayQueue<T> implements QueueInterface<T> {	private T[] queue; // Circular array of queue entries	private int frontIndex; // Index of front entry	private int size; // No need to keep track of the backIndex because...	// ...the back index can be calculated from:	// backIndex = (frontIndex + size) % queue.length	// Plus, there is only one place in the code where we really need the back	// index.	private static final int DEFAULT_CAPACITY = 4;	/**	 * Constructs a queue with default initial array capacity	 */	public ArrayQueue() {		this(DEFAULT_CAPACITY);	}	/**	 * Constructs a queue with a specified initial array capacity	 * 	 * @param initialCapacity the desired initial array capacity	 */	@SuppressWarnings("unchecked")	public ArrayQueue(int initialCapacity) {		this.queue = (T[]) (new Object[initialCapacity]);		this.frontIndex = 0;		this.size = 0;	}	@Override	public void add(T newEntry) {		checkSize();		// we know that the array has room to do the add		// add() happens at the back of the data		int backIndex = (this.frontIndex + size) % queue.length;		queue[backIndex] = newEntry;		size++;	}	@Override	public T peek() {		// happens at the front index		if (size == 0) {			throw new NoSuchElementException("queue is empty");		}		return queue[this.frontIndex];	}	@Override	public T remove() {		// call peek() as first line of code		T front = peek();		queue[this.frontIndex] = null;		this.frontIndex = (this.frontIndex + 1) % queue.length;		this.size--;		return front;	}	@Override	public boolean isEmpty() {		return size == 0;	}	@Override	public void clear() {		for (int i = 0; i < this.size; i++) {			queue[(this.frontIndex + i) % queue.length] = null;		}		this.size = 0;		this.frontIndex = 0;	}	public String toString() {		String result = "FRONT [";		for (int i = 0; i < size; i++) {			result += queue[(this.frontIndex + i) % queue.length] + " ";		}		result = result.trim() + "] BACK";		return result;	}	// Doubles the size of the array queue if it is full.	private void checkSize() {		if (size == queue.length) {			T[] oldQueue = queue;			@SuppressWarnings("unchecked")			T[] tempQueue = (T[]) new Object[2 * size];			queue = tempQueue;			for (int i = 0; i < size; i++) {				tempQueue[i] = oldQueue[(this.frontIndex + i) % oldQueue.length];			}			this.frontIndex = 0;		}	}}