import java.util.NoSuchElementException;/** * A class that implements the ADT queue by using a chain of linked nodes that * has references to the front and end of the chain. Adds will be after the last * node. Removes will be from the front node. */public final class LinkedQueue<T> implements QueueInterface<T> {	private Node<T> firstNode; // References node at front of queue	private Node<T> lastNode; // References node at back of queue	public LinkedQueue() {		firstNode = lastNode = null;	}	public void add(T newEntry) {		// adds happen at the last node		// double-check special cases: size-zero queue, and size-1 queue		Node<T> temp = new Node<>(newEntry);		if (firstNode == null) { // handles zero node case			firstNode = lastNode = temp;		} else { // handles everything else (incl. size-1 case)			lastNode.next = temp;			lastNode = temp;		}	}	public T peek() {		if (firstNode == null) {			throw new NoSuchElementException("queue is empty");		}		return firstNode.data;	}	public T remove() {		// first line of code: call peek() which handles zero-node case		// consider the one-node special case		T first = peek();				if (firstNode == lastNode && firstNode != null) { // handles one-node case			firstNode = lastNode = null;		} else { // handles all other cases			firstNode = firstNode.next;		}				return first;	}	public boolean isEmpty() {		return firstNode == null;	}	public void clear() {		firstNode = lastNode = null;	}	public String toString() {		String result = "FRONT [";		Node<T> curr = firstNode;		while (curr != null) {			result += curr.data + " ";			curr = curr.next;		}		result = result.trim() + "] BACK";		return result;	}	private class Node<E> {		private E data;		private Node<E> next;		private Node(E data) {			this.data = data;			this.next = null;		}	}}